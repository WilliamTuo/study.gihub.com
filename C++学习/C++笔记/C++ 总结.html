<html>
<head>
  <title>C++ 总结</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600240 (zh-CN, DDL); Windows/6.1.1 (Win32);"/>
  <meta name="application-data:QZONE_SHARE_FLAG" content="success,0,0,1548162736741"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1574"/>
<h1>C++ 总结</h1>

<div><span><div><div><div>1. 关键字 （c++98 中有 63 个 ， c++ 11 增至 73 个（最右列的是新增 11 个关键字））</div><div><br/></div><div><br/></div><div>2.命名空间( namespace )： </div><div>        概念：用来组织和重用代码的编译单元</div><div>        作用：对标识符的名称进行本地化，以避免命名冲突或名字污染</div><div>        定义方式：普通命名空间、命名空间的嵌套、相同名称的命名空间（编译器会合并为一个）</div><div>        使用方式： 【命名空间名字:: 】、【using 命名空间的名字::成员名字】、【using namespace 命名空间的名字】（第3种可能造成命名空间冲突的情况）</div><div><br/></div><div>3.缺省参数： </div><div>        概念：给函数参数带的默认值，用户在调用该函数时可以传递（传递的实参）也可以不用传递（缺省值）</div><div>        分类： 全缺省（所有的参数都带有默认值）、半缺省（部分参数带有缺省值（缺省参数只能从右到左依次给出））；</div><div>        </div><div>        注意，  1 .半缺省参数只能从右至左依次给出； </div><div>                    2.声明和定义不能同时给出</div><div>                    3.全缺省的函数与无参函数可以构成重载，但一般情况下最好不要同时存在。</div><div><br/></div><div>4.函数重载：</div><div>        概念： 1.同一个作用域； 2.函数名相同； 3.参数列表不同（参数个数，参数类型，参数的类型次序不同）； 4.与返回值类型 是否相同无关。</div><div><br/></div><div>        调用：编译器根据实参的类型确定调用哪个函数（在编译期间）。</div><div><br/></div><div>        extern &quot;C&quot; 的作用： 在 C++ 工程中，告诉编译器按照 C 的风格进行编译</div><div><br/></div><div>        名字修饰规则：</div><div>                1.C 的修饰规则：仅在函数名前面加 &quot;_&quot; </div><div>                2.C++ 的修饰规则： 将参数的类型增加到函数名里面，代码中函数名字相同，编译器最终使用的名字不同</div><div>                        vs 名字修饰、g++ 名字修饰</div><div>5.引用</div><div>        概念：别名，编译器不会为引用变量开辟新的内存空间，与它的实体共用同一块内存</div><div><br/></div><div>        定义： 类型&amp;引用变量的名字 = 实体； </div><div>                  注意，引用变量的类型必须与其引用实体的类型相同。</div><div>        特性： </div><div>                1.必须初始化； </div><div>                2.一旦与一个实体结合，不能在引用其他的实体， </div><div>                3.一个实体可以有多个引用，一个引用只能有一个实体。</div><div><br/></div><div>        const 类型的引用： 1.int a = 10;     const int &amp;ra = a;     //不能通过 ra 改变里面的内容；</div><div>                                        2.const int &amp;ra = 10;     //一般情况不用这种方式</div><div>                                        3.double d = 12.34;    const int &amp;rd = d;   //临时变量具有常属性，普通的引用不能引用（传参）</div><div>        右值引用：</div><div><br/></div><div>        调用场景：</div><div>                    1.引用变量</div><div>                    2.引用作函数的参数，如果在函数不需要对形参进行修改，最好加 const </div><div>                    </div><div>                    3.引用作函数的返回值， </div><div>                        注意， 不能返回栈上的空间，返回实体的类型不受函数的控制（全局变量，局部静态变量、引用类型的参数、堆上空间的对象）</div><div>    </div><div>        引用传参 传值 和 传地址的区别：</div><div>                1.传值：</div><div>                2.传地址：</div><div>                3.传引用：</div><div><br/></div><div>        引用与指针的区别：</div><div>            1.相同点：底层的实现完全相同（引用就是按照指针的方式来实现的， 说明：<span style="font-weight: bold;">引用实际也有空间 </span> T&amp; == T* const;     const T&amp; == const T* const）</div><div>    </div><div>            2.不同点：</div><div>                    1.引用必须初始化，指针不用；</div><div>                    2.引用不能为空，指针可以为空；</div><div>                    3.引用只能被初始化一次，指针可以改变；</div><div>                    4.sizeof 的含义不同： 引用的结果是引用类型的大小， 但指针始终是 地址空间所占字节个数（32位 和 64位）。</div><div>                    5.引用自增是所引用实体的自增， 指针是向后偏移一个类型的大小；</div><div>                    6.有多级指针，但是不存在 多级引用；</div><div>                    7.访问实体的方式不同，指针需要显式解引用，引用编译器自己处理；</div><div>                    8.引用比指针使用起来更加安全。</div><div><br/></div><div>6.宏 与 内联函数</div><div>        宏的优缺点： （宏常量、宏函数）</div><div>            优点：</div><div>                    增强代码的复用性；</div><div>                    提高性能。</div><div>            缺点：</div><div>                    不方便调试。（预编译阶段进行了替换）</div><div>                    导致代码可读性变差，可维护性查，容易误用；</div><div>                    没有类型安全的检查。</div><div><br/></div><div>        c++替换宏： </div><div>            用 const 变量替换宏常量</div><div>            用内联函数替换宏函数</div><div>  </div><div>        内联函数</div><div>            概念：</div><div>                    inline （建议编译器按照内联函数处理） </div><div>            说明：</div><div>                    1.建议性的关键字 inline </div><div>                    2.不要有循环、 不要有递归、不要太长（否则会降低效率）         </div><div>                    3.成员函数在类中定义：编译器可能会把它当成内联函数来处理 --- 测</div><div><br/></div><div>7.c++11(auto/ 范围 for / c++ 空值指针 nullptr)</div><div>        auto:</div><div>                简介：</div><div>                    新的类型指示符指示编译器， auto 声明的变量必须由编译器在编译时期推导。</div><div>                    理解： 它是一种类型声明的“占位符”，并非“类型”的声明</div><div>                使用细则：</div><div>                    1.用 auto 声明指针类型时， auto 和 auto* 没有什么区别，但用 auto 声明引用类型时必须加 &amp;</div><div>                    2.当一行定义多个变量时，必须类型一致，否则报错。 （根据第一个变量类型进行推导，然后用推导出来的类型定义其他变量）。</div><div><br/></div><div>                auto <span style="font-weight: bold;">不能</span>使用的场景</div><div>                    1.不能作为函数的参数</div><div>                    2.不能直接用来声明数组</div><div>                    3.C++11 只保留了 auto 作为类型指示符的用法</div><div>                    4.auto 不能定义类的非静态成员变量</div><div>                    5.实例化模板时不能使用 auto 作为模板参数    </div><div>                </div><div>                auto 在实际中最常见的用法就是 与 范围 for ，还有 lambda 表达式进行配合使用。</div><div><span style="font-weight: bold;">                        </span></div><div>        范围 for:</div><div>            语法： for 循环后面的括号由 冒号“:”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。</div><div>            使用条件：</div><div>                    1.迭代的范围必须是确定的</div><div>                    2.迭代的对象要实现了 ++ 和 == 的操作。        </div><div>            </div><div>        空值指针 nullptr: （C++11 为了避免混淆所提供， 它代表一个指针空值常量）</div><div>                注意：</div><div>                    1.在使用 nullptr 时，不需要包含头文件，它是作为一个关键字引入的。</div><div>                    2.在 c++11 中， sizeof(nullptr) 和 sizeof((void *) 0) 所占的字节数相同；</div><div>                    3.为了提高代码的健壮性，建议 表示指针空值 使用 nullptr。</div><div><br/></div><hr/><div><br/></div><div>类 和 对象：</div><ol><li><div>面向过程（菜品，过程）</div></li><li><div>面向对象（做菜， 菜谱）</div></li><li><div>类</div></li><ol><li><div>类的定义：成员变量、成员函数、 struct 和 class </div></li></ol><li><div>封装</div></li><ol><li><div>封装的概念： 将数据 和 操作数据的方法有机结合，隐藏对象的属性 和 实现细节，进对外公开接口和对象进行交互。</div></li><li><div>C++ 封装的实现：</div></li><ol><li><div>类</div></li><li><div>访问限定符（private/public/protected） 注意点：...</div></li></ol></ol><li><div>类的作用域</div></li><li><div>实例化</div></li><li><div>对象模型</div></li><ol><li><div>对象模型1</div></li><li><div>对象模型2</div></li><li><div>对象模型3</div></li><li><div>类大小的计算方式： 类的大小就是该类中“成员变量“之和，也要进行内存对齐。</div></li><li><div>空类（大小为 1 字节，用来唯一标识该类）</div></li></ol><li><div>this 指针</div></li><ol><li><div>什么是 this 指针？ 答： <span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(238, 238, 238); color: rgb(178, 34, 34); font-family: 微软雅黑, &quot;Microsoft Yahei&quot;, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器将它添加到参数列表中。</span></div></li><li><div>this 指针的特性（传递的方式等）</div></li><ol><li><div>this 指针的类型： 类类型* const</div></li><li><div>只能在“成员函数”的内部使用。</div></li><li><div>this 本质上是非静态成员函数的第一个形参，是对象调用非静态成员函数时，将对象的地址作为实参传给 this 形参。对象中不存储 this 指针。</div></li><li><div>this 指针是非静态成员函数的隐含指针形参，一般由编译器通过 ecx 寄存器自动传递，不需要用户传递。</div></li></ol><li><div>编译器对类的处理</div></li><ol><li><div>识别类名</div></li><li><div>识别成员变量</div></li><li><div>识别成员函数并且对成员函数名以及函数体进行改写</div></li></ol><li><div>this 指针是否可以为空？ 答：如果 this 指针为空，可以通过编译，调用函数，但是在成员函数中不能通过 this 访问成员变量。否则，编译器报错。</div></li><li><div>this 指针存储的位置？ 答： <span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑, &quot;microsoft yahei&quot;, Tahoma, Helvetica, SimSun, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">其实编译器在生成程序时加入了获取对象首地址的相关代码。并把获取的首地址存放在了寄存器ECX中(VC++编译器是放在ECX中，其它编译器有可能不同)。也就是成员函数的其它参数正常都是存放在栈中。</span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14px; color: rgb(28, 51, 135); font-family: 微软雅黑, &quot;microsoft yahei&quot;, Tahoma, Helvetica, SimSun, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">而this指针参数则是存放在寄存器中</span></span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑, &quot;microsoft yahei&quot;, Tahoma, Helvetica, SimSun, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">。类的静态成员函数因为没有this指针这个参数，所以类的静态成员函数也就无法调用类的非静态成员变量</span></div></li></ol><li><div>类中六个默认的成员函数</div></li><ol><li><div>构造函数</div></li><ol><li><div>概念： 特殊的成员函数（在创建对象期间由编译器自动调用完成对象的初始化工作）</div></li><li><div>特性： </div></li><ol><li><div>名字与类名相同</div></li><li><div>没有返回值</div></li><li><div>可以重载</div></li><li><div>只能被调用一次，编译器调用（创建对象期间）</div></li><li><div>缺省的构造函数（无参的构造函数、 带有全缺省的构造函数）两种缺省函数只能存在一个。</div></li><li><div>如果没有显式定义，编译器会自动生成一个默认构造函数（一定是无参的）</div></li><li><div>如果编译器需要，生成默认的构造函数： </div></li><ol><li><div>类中包含一个自定义 类 类型的对象  并且该类没有显式提供任何的构造函数  而且内部包含的自定义对象的类 有缺省的构造函数。</div></li><li><div> 基类带有默认构造函数 的派生类。 原因： 派生类被合成需要显式调用基类默认的构造函数</div></li><li><div>虚拟继承： 如果用户没有显式 指定派生类的构造函数，编译器会生成一个默认的构造函数。</div></li><li><div> 多态： 包含虚函数的类，编译器会默认给它生成构造函数</div></li></ol><li><div>构造函数的初始化列表</div></li><ol><li><div>概念：完成对象的初始化工作，  构造函数体中赋值</div></li><li><div>书写方式： 构造函数名字后接： 冒号后面跟类中需要初始化的非静态的成员变量</div></li><li><div>初始化顺序：与成员变量在类中的声明次序一致，与成员变量在初始化列表中出现的先后次序无关。  注意， 尽量避免使用成员变量初始化</div></li><li><div>必须在初始化列表初始化的成员：</div></li><ol><li><div>引用类型的成员变量</div></li><li><div>const 类型的成员变量</div></li><li><div>类中包含自定义类型的成员（含有非缺省的构造函数）</div></li></ol><li><div>初始化列表中不能出现 this 指针</div></li></ol><li><div>不能用 const 修饰：因为可能需要对对象中的成员进行赋值</div></li><li><div>不能用 static 修饰：static 修饰的是共享的成员，构造函数初始化的是对象中的非静态成员变量</div></li><li><div>不能用 virtual 修饰： 在构建对象时首先初始化的是虚表指针，需要知道对象的地址，在构造函数调用时对象还不完整，对象的地址不明确。</div></li></ol><li><div>默认的构造函数</div></li><li><div>调用场景：在创建对象时，由编译器自动调用</div></li><li><div>作用：</div></li><ol><li><div>构造函数</div></li><li><div>初始化对象</div></li><li><div>单参构造函数具有类型转化的作用， explicit 修饰构造函数：进制单参构造函数类型转化作用</div></li></ol></ol><li><div>拷贝构造</div></li><ol><li><div>概念：构造函数的重载形式，一定是单参的，参数一定是类类型的引用(最好 const)，用对象创建对象时由编译器自动调用</div></li><li><div>特性</div></li><ol><li><div>构造函数的特性拷贝构造都满足</div></li><li><div>参数必须是类类型对象的引用，如果是传值的方式，会形成无限递归</div></li><li><div>在用对象创建对象有编译器自动调用</div></li></ol><li><div>调用场景</div></li><ol><li><div>用对象作为形参</div></li><li><div>用对象作为函数的返回值类型： 特例：按照值的方式返回： return T( )；不会调用构造临时对象</div></li></ol><li><div>默认拷贝构造函数: 浅拷贝</div></li><li><div>如果类中管理了资源，该类必须显式提供拷贝构造函数</div></li></ol><li><div>赋值运算符重载</div></li><ol><li><div>运算符重载</div></li><ol><li><div>运算符重载与函数重载的区别？</div></li><li><div>作用：提高代码的可读性</div></li><li><div>哪些运算符可以重载？</div></li><li><div>注意： </div></li><ol><li><div>操作数至少有一个是自定义类型的</div></li><li><div>必须符合该运算符的特性</div></li><li><div>不能重载<span style="font-weight: bold;">不可以重载的运算符</span></div></li><li><div>如果重载成类的成员函数，参数少了一个</div></li><li><div>== 和 ！= 成对重载</div></li></ol><li><div>重载过的运算符</div></li><ol><li><div>前置++ 与 后置++</div></li><li><div>下标运算符 [ ]</div></li><li><div>输入运算符 &gt;&gt; 和 输出运算符 &lt;&lt; </div></li><li><div>函数调用运算符 &quot;( )&quot; ：支持函数对象</div></li><li><div>*</div></li><li><div>-&gt;</div></li><li><div>== 和  !=  </div></li></ol></ol><li><div>如何重载赋值运算符</div></li><ol><li><div>函数名字： operator =</div></li><li><div>返回值类型：类类型对象的引用（连续赋值，效率高）</div></li><li><div>参数类型：一般情况类类型对象的 const 引用</div></li><li><div>函数体：</div></li><ol><li><div>检测是否自己给自己赋值</div></li><li><div>返回内容： return *this</div></li></ol></ol><li><div>如果没有显式提供，编译器会生成一个默认的赋值运算符的重载： 注意，默认生成的是浅拷贝的方式</div></li><li><div>如果类中管理了资源，用户必须显式提供赋值运算符的重载</div></li></ol><li><div>析构函数</div></li><ol><li><div>概念：与构造函数的功能相反，在对象被销毁时，由编译器自动调用，完成对象中资源的清理</div></li><li><div>特性</div></li><ol><li><div>类名前加 ~</div></li><li><div>在对象被销毁时由编译器自动调用，并且在对象的生命周期内只调用一次</div></li><li><div>清理对象中的资源，而不是删除对象</div></li></ol><li><div>调用场景</div></li><ol><li><div>在对象销毁时由编译器自动调用</div></li></ol><li><div>默认的析构函数</div></li><ol><li><div>语法：如果没有显式提供，编译器会生成一份</div></li><li><div>编译器如果需要，会自己合成一份</div></li></ol><li><div>如果类中管理了资源，一定要显式提供，在对象被销毁时 要完成对象的清理工作</div></li><li><div>什么情况下最好把析构函数定义为虚函数？ 答： 基类指针指向子类对象，然后 delete 基类的指针，这种情况需要将基类的析构函数声明成虚函数。否则如果派生类中管理了资源，会造成内存泄漏，只释放了基类中的资源。</div></li></ol><li><div>T* operator &amp;( ) 和  const T* operator &amp;( ) const  区别  </div></li></ol><li><div>const 类型的成员</div></li><ol><li><div>const 类型的成员变量</div></li><ol><li><div>不能被修改</div></li><li><div>必须在初始化列表的位置进行初始化</div></li><li><div>如果类里面包含 const 类型的成员变量，必须显式给出其构造函数</div></li></ol><li><div>const 类型的成员函数</div></li><ol><li><div>const 修饰成员函数实际修饰成员函数隐藏的 this 指针</div></li><li><div>在 const 成员函数中，不能修改类的非静态成员变量</div></li><li><div>如果成员变量前使用 mutable 关键字修饰，在 const 成员函数中可以被修改</div></li></ol><li><div>const 不能修饰构造函数与静态的成员函数</div></li><li><div>const 成员函数与普通成员函数的区别</div></li><li><div>const 对象与普通对象的区别</div></li></ol><li><div>静态成员</div></li><ol><li><div>在 C 语言中：</div></li><ol><li><div>修饰变量：</div></li><ol><li><div>全局变量，</div></li><li><div>局部变量</div></li><li><div>存储位置</div></li></ol><li><div>修饰函数：改变了函数的链接属性，具有文件作用域</div></li></ol><li><div>在 C++ 中：</div></li><ol><li><div>static 修饰类成员</div></li><ol><li><div>修饰成员变量：</div></li><ol><li><div>static 成员变量必须在类外进行定义</div></li><li><div>static 成员变量是类的属性，不属于某个具体的对象</div></li><li><div>所有对象共享的</div></li><li><div>不影响 sizeof 的结果</div></li><li><div>使用方式： 1.类名 + 作用域； 2.对象. ==》类名+作用域</div></li></ol><li><div>修饰成员函数</div></li><ol><li><div>static 成员函数没有 this 指针</div></li><li><div>static 成员函数中不能访问类的非静态 成员变量和成员函数</div></li><li><div>static 成员函数不能用 const 修饰</div></li><li><div>static 不能修饰构造、拷贝构造、赋值运算符重载、析构</div></li><li><div>static 不能修饰虚函数</div></li></ol></ol></ol></ol><li><div>友元</div></li><li><div>内部类</div></li><li><div>日期类</div></li></ol><hr/><div>动态内存管理</div><ol><li><div>内存分布</div></li><ol><li><div>内核区域</div></li><li><div>用户区域</div></li><ol><li><div>代码段</div></li><li><div>数据段</div></li><li><div>堆栈区</div></li></ol></ol><li><div>C 语言中动态内存管理的方式</div></li><li><div>空间的申请</div></li><ol><ol><li><div>void * malloc(size_t size); （返回空间必须判空）</div></li><li><div>void * calloc(类型的个数， 类型的大小 ) 会对它申请的空间进行初始化----》0</div></li><li><div>void * realloc(void *p, size_t size(字节数));  调整空间大小</div></li><ol><li><div>如果 p 为 NULL， 类似 malloc </div></li><li><div>如果 p 不为 NULL， </div></li><ol><li><div>如果 size &lt; 原空间的大小，直接将原空间的地址返回，空间定义为 size 空间的大小</div></li><li><div>如果 size &gt; 原空间的大小： 原空间后未申请的空间 和 原空间大小可以提供 size 空间，返回原空间地址；   原空间后未申请的空间 和 原空间不能提供 size 空间，重新申请，返回重新申请后的空间的地址。</div></li></ol></ol></ol><li><div>空间的释放</div></li><ol><li><div>p 所指向的空间必须是堆上申请的空间</div></li><li><div>p == NULL</div></li></ol><li><div>malloc （细查）</div></li><ol><li><div>vs</div></li><li><div>linux</div></li></ol></ol><li><div>C++ 动态内存管理的方式</div></li><ol><li><div>兼容 C 语言的方式</div></li><li><div>new/delete 和 new[]/delete[]</div></li><ol><li><div>内置类型：C++ 的方式 与 C 语言的方式基本类似</div></li><li><div>自定义类型</div></li><ol><li><div>未提供析构函数</div></li><li><div>提供析构函数</div></li><ol><li><div>new T</div></li><ol><li><div>operator new( new 后类型的大小 )： </div></li><ol><li><div>循环调用 malloc 申请</div></li><li><div>空间不足的应对措施---函数（用户提供）</div></li><li><div>空间不足的应对措施未提供---抛异常</div></li></ol><li><div>在申请的空间上执行构造函数 </div></li></ol><li><div>delete </div></li><ol><li><div>调用析构函数，释放对象中的资源</div></li><li><div>调用 void operator delete(void *p(所释放空间的地址))  free( p )</div></li></ol><li><div>new T[ N ]</div></li><ol><li><div>void * operator new[](size = sizeof(T) * N + 4（放对象的个数）) --&gt; void *operator new(size)</div></li><li><div>在空间前 4 个字节放对象的个数（在释放空间时，必须知道调用析构函数的次数）</div></li><li><div>将空间的首地址 向后偏移 4 个字节的位置开始构造 N 个对象</div></li><li><div>将第一个对象的地址返回给用户</div></li></ol><li><div>delete []p（p 是 N 个对象中第一个对象的首地址）</div></li><ol><li><div>释放对象中的资源</div></li><ol><li><div>从空间前 4 个字节取出析构函数的调用次数 N</div></li><li><div>从后往前调用 N 次析构函数，销毁每个对象中的资源</div></li></ol><li><div>释放空间</div></li><ol><li><div>void operator delete[](将 p 向前移动 4 个字节的位置开始释放)--&gt;operator delete(p)---&gt; free(p)</div></li></ol></ol></ol></ol></ol><li><div>void * operator new(size) 和 void operator delete(p) （需不需要调用构造 和 析构函数）： 不调用</div></li><ol><li><div>系统提供（通过 malloc 从堆上申请，浪费 4 字节的内存）</div></li><li><div>用户可以重写（比如从空间配置器中申请空间）</div></li><ol><li><div>全局</div></li><li><div>类中的成员函数</div></li></ol></ol><li><div>定位 new 表达式</div></li><ol><li><div>概念：在已经存在的空间上执行构造函数</div></li><li><div>用法： new( p ) T; </div></li><li><div>为了与 new 统一：调用 void * operator new( size_t size, void * where ) { return where; };</div></li><li><div>内存池</div></li><li><div>使用场景： 定位 new 表达式在实际中一般是配合内存池使用。因为内存池分配出的内存没有初始化，所以如果是自定义类型的对象，需要使用 new 的定义表达式进行显示调构造函数进行初始化。</div></li></ol></ol><ol><li><div>相关的面试题</div></li><ol><li><div>关于内存泄漏</div></li><ol><li><div>检测： 检查代码、使用相关工具(linux 中自带的内存泄漏检测工具)</div></li><ol><li><div>valgrind <a href="https://blog.csdn.net/gatieme/article/details/51959654">https://blog.csdn.net/gatieme/article/details/51959654</a></div></li></ol><li><div>避免：良好编程习惯、不要使用原生态指针（可以使用智能指针避免）</div></li></ol><li><div>在析构函数中不能调用 delete this 。 （会造成无穷递归）</div></li><li><div>如何将工程按照 64 位进行编译（前提：系统是 64 位）</div></li><li><div>malloc/free 和 new/delete 的区别</div></li><ol><li><div> malloc/free 是函数， new/delete 是操作符</div></li><li><div> malloc 申请空间的返回值是 void *，new 返回的是申请时传递的空间的类型</div></li><li><div> malloc 失败返回 NULL，使用时必须判空，new 需要捕获异常</div></li><li><div> malloc 只能在堆上申请空间， new 可以通过重载 operator new 函数重新实现</div></li><li><div> malloc 申请空间需要用户计算需要申请空间的大小， new 只需要跟上空间的类型</div></li><li><div> malloc 只能申请内置类型的空间，new 在申请空间后会调用构造函数完成对象的构造</div></li><li><div> new/delete 相比于 malloc/free 效率稍低，因为它们底层调用的是 malloc/free</div></li></ol><li><div>特殊类的设计</div></li><ol><li><div>只能在堆上创建对象</div></li><ol><li><div>将构造函数私有化</div></li><li><div>提供静态的成员函数---new 对象并返回</div></li><li><div>防止用堆上的对象在栈上来构造（下方 3 给出的 2 种情况）</div></li></ol><li><div>只能在栈上创建对象</div></li><ol><li><div>将 operator new(size_t size) 私有化, 注意，屏蔽了 operator new,实际也屏蔽了定位 new 。</div></li><li><div>提供静态的成员函数---创建临时对象并返回</div></li></ol><li><div>如何让一个类防止被拷贝</div></li><ol><li><div>C++98 将拷贝构造 以及 赋值运算符 只声明不定义并且定义成私有</div></li><li><div>C++11 拷贝构造（）= delete;</div></li></ol><li><div>一个类如何只能创建一个对象（单例模式）</div></li><ol><li><div>饿汉模式（程序启动时就创建该对象，需要时直接使用）</div></li><ol><li><div>构造函数私有，提供一个静态的成员变量</div></li><li><div>缺点： 静态的成员在程序启动时创建，降低程序启动时间； 如果两个单例对象有依赖关系，无法保证</div></li><li><div>适用场景： 多线程高并发环境</div></li></ol><li><div>懒汉模式（延迟加载：在程序第一个需要时在创建）</div></li><ol><li><div>使用场景： 如果单例对象构造十分耗时或者占用较多的资源，比如，加载插件，初始化网络连接，读取文件等，有可能该对象运行时不会用到， 要在程序一开始就进行初始化，就会导致程序启动的十分迟缓，  这种情况使用懒汉模式 更好。</div></li></ol></ol></ol></ol></ol></ol><hr/><div>模板</div><ol><li><div>泛型编程： 与类型无关 和 与数据结构无关</div></li><li><div>函数模板</div></li><ol><li><div>概念：函数模板代表了一个函数家族，与类型无关，在使用时被参数化，根据实参的类型产生函数的特定版本</div></li><li><div>用法：template&lt;typename T1, typename T2,......,typename T&gt;</div></li><li><div>实例化</div></li><ol><li><div>隐式实例化： 没有明确指定模板参数列表中类型参数的实际类型，需要编译器在编译阶段，对实参的类型进行推演来确定模板参数列表中类型参数的实际类型，编译器根据确定的类型结合模板来生成具体类型的代码。注意，一般不进行隐式实类型转化</div></li><li><div>显式实例化：</div></li><ol><li><div>明确指定模板参数列表中实参的类型</div></li><li><div>编译器不需要进行参数推演，直接生成对应的模板函数</div></li><li><div>如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报</div></li></ol></ol></ol><li><div>类模板</div></li><ol><li><div>用法： template&lt;class T1, class T2, ..., class T&gt; class 类模板名 ｛类中的成员｝；</div></li><li><div>注意： 类模板中函数放在类外进行定义时，需要加模板参数列表</div></li><li><div>类模板的实例化：类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟 &lt;&gt;，然后将实例化的类型放在 &lt;&gt; 中即可，类模板名字不是真正的类，而实例化的结果才是真正的类。</div></li></ol><li><div>模板的特化</div></li><ol><li><div>函数模板的特化</div></li><li><div>类模板的特化</div></li><ol><li><div>全特化</div></li><li><div>偏特化</div></li></ol><li><div>类模板特化的应用</div></li><ol><li><div>类型萃取： 写一个通用的拷贝函数 </div></li><ol><li><div>memcpy </div></li><ol><li><div>优点：效率高</div></li><li><div>缺点： 浅拷贝</div></li></ol><li><div>for 循环一个一个赋值</div></li><ol><li><div>优点：一定不会出错</div></li><li><div>缺点：效率低</div></li></ol><li><div>被拷贝对象的类型： 内置类型 和 自定义类型</div></li><ol><li><div>FalseType--&gt;自定义类型； TrueType--&gt;内置类型</div></li><li><div>类模板</div></li><li><div>对类模板使用所有的内置类型进行特化</div></li><li><div>完成通用的拷贝函数</div></li></ol></ol></ol></ol><li><div>模板的分离编译</div></li><ol><li><div>课件中的链接</div></li><li><div>程序员的自我修养</div></li></ol></ol><div><br/></div></div><hr/><div>STL</div><ol><li><div>概念：</div></li><li><div>通俗的说，常见数据结构封装 + 通用算法</div></li><li><div>六大组件</div></li><ol><li><div>容器：存放数据</div></li><ol><li><div>序列式容器：线性结构</div></li><ol><li><div>string 类</div></li><ol><li><div>刷题</div></li><li><div>浅拷贝问题</div></li><ol><li><div>深拷贝</div></li><ol><li><div>传统写法</div></li><li><div>现代写法</div></li></ol><li><div>写时拷贝： </div></li><ol><li><div>浅拷贝 + 引用计数+ 在所有可能会发生修改的操作中分离出当前对象</div></li><li><div>线程安全问题</div></li></ol></ol></ol><li><div>C++11 : array （静态数组（静态顺序表））</div></li><li><div>vector: 动态的顺序表</div></li><li><div>list: 带头节点的双向循环列表</div></li><li><div>deque：类似于动态的二维数组</div></li><li><div>C++11: forward_list: 带头节点的循环单链表</div></li></ol><li><div>关联式容器</div></li></ol><li><div>适配器(特殊的容器， 不需要迭代器)：</div></li><ol><li><div>容器适配器</div></li><ol><li><div>stack:</div></li><li><div>queue:</div></li><li><div>priority_queue:</div></li><ol><li><div> vector + 堆相关算法</div></li><li><div>缺省情况： 大堆</div></li><li><div>priority_queue&lt;T, vector&lt;T&gt;, less（大堆）/greater（小堆）&lt;T&gt;&gt;</div></li></ol></ol><li><div>迭代器适配器：反向迭代器</div></li></ol><li><div>迭代器</div></li><ol><li><div>设计模式</div></li><ol><li><div>原生态的指针 vector</div></li><li><div>将指针封装一个类</div></li><ol><li><div>T&amp; operator*( )</div></li><li><div>T* operator-&gt;( )</div></li><li><div>self&amp; operator++( ) / self operator++( int )</div></li><li><div>bool operator!=( const self &amp; s);</div></li><li><div>bool operator==( const self &amp; s);</div></li><li><div>self&amp; operator--( ) / self operator--( int )</div></li></ol></ol></ol><li><div>算法</div></li><ol><li><div>与数据结构相关</div></li><li><div>通用算法</div></li><ol><li><div>数值相关</div></li><li><div>排序</div></li><li><div>查找</div></li><li><div>遍历</div></li><li><div>集合</div></li></ol></ol><li><div>仿函数（函数对象）： </div></li><ol><li><div>将一个类的对象可以像函数调用的方式来使用</div></li><li><div>在类中只需要将：  operator( )(参数列表) 重载</div></li></ol><li><div>空间配置器：申请释放管理空间</div></li></ol></ol><div><br/></div><div><br/></div><hr/><div>I/O 流</div><ol><li><div>C++ 中标准 I/O</div></li><ol><li><div>键盘输入: cin（输入流对象）</div></li><li><div>控制台 cout（输出流对象）</div></li><li><div>OJ: 输入 和 输出</div></li></ol><li><div>文件 I/O </div></li><ol><li><div>文件的分类</div></li><ol><li><div>文本文件</div></li><li><div>二进制文件</div></li></ol><li><div>C 文件操作的函数</div></li><li><div>如何检测文件是否读取到结尾</div></li><li><div>C++ 文件 IO 流对象</div></li><ol><li><div>ofstream: 从内存读取到文件</div></li><li><div>ifstream: 从文件读到内存</div></li></ol></ol></ol><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 