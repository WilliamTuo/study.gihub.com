<html>
<head>
  <title>线程 互斥量</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600240 (zh-CN, DDL); Windows/6.1.1 (Win32);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="572"/>
<h1>线程 互斥量</h1>

<div>
<span><div><div><span style="font-weight: bold;">//互斥锁</span></div><div>1.定义一个互斥量  pthread_mutex_t mutex</div><div>2.初始化信号量    pthread_mutex_init(&amp;mutex, NULL);  //初始化为1</div><div>3.上锁                  pthread_mutex_lock(&amp;mutex);  ：1-&gt;0， 并返回   </div><div>                                                                                 0-&gt;等待</div><div>    附记： pthread_mutex_trylock(pthread_mutex_t *mutex); //非阻塞加锁</div><div>4.解锁                 pthread_mutex_unlock(&amp;mutex);  置1， 返回</div><div>5.销毁                 pthread_mutex_destroy(&amp;mutex);</div><div><br/></div><div>//关键字restrict 只能用在形参前，并且必须是指针</div><div>//它会把形参的地址放在寄存器中，每次使用时不需要去内存取，用于优化。</div><div> </div><hr/><div>//下面两个函数必须成对出现</div><div>void pthread_cleanup_push(void (*routine)(void *),   //回调函数</div><div>                                                  void *arg);    //回调函数的参数</div><div>    回调函数执行时机：</div><div>                1.pthread_exit</div><div>                2.pthread_cancel</div><div>                3.cleanup_pop参数不为 0，执行到cleanup_pop时触发回调函数</div><div><br/></div><div>void pthread_cleanup_pop(int execute);</div><div><br/></div><hr/><div><br/></div><div><span style="font-weight: bold;">//自旋锁</span>(嵌入式开发使用较多): 应用在实时性要求比较高的场合</div><div>    pthread_spinlock_t spin;</div><div>    pthread_spin_init()</div><div>    pthread_spin_lock()    //得不到， busy loop</div><div>    pthread_spin_unlock()</div><div>    pthread_spin_destroy()</div><div><br/></div><div><span style="font-weight: bold;">//读写锁</span>： 应用场景，大量读，很少写，操作耗时短</div><div>读写锁默认读优先</div><div>读写锁通过 计数器 + 自旋锁 实现</div><div>读读共享，读写互斥</div><div><br/></div><div>pthread_rwlock_t rwlock;</div><div>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, //读写锁变量</div><div>              const pthread_rwlockattr_t *restrict attr);  //读写锁属性</div><div>返回值：成功返回 0， 失败返回错误编号。</div><div><br/></div><div>附记：</div><div>    int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr); //属性销毁</div><div>    int pthread_rwlockattr_init(pthread_rwlockattr_t *attr); //属性初始化</div><div><br/></div><div>    pthread_rwlockattr_setkind_np //设置读写锁属性（写锁优先）</div><div>    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP  //写锁优先级</div><div><br/></div><div><span>    </span>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</div><div><span>    </span>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)；</div><div><br/></div><div><span>    </span>pthread_rwlock_unlock()</div><div><br/></div><div><span>    </span>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</div><div><br/></div><div><br/></div><div>读写锁特性：</div><div><span style="font-size: 14px; overflow-wrap: break-word; text-indent: 2em; zoom: 1; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;">        1.一次只有一个</span><a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B" style="font-size: 14px; overflow-wrap: break-word; text-indent: 2em; zoom: 1; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(19, 110, 194); font-family: arial, 宋体, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;">线程</a><span style="font-size: 14px; overflow-wrap: break-word; text-indent: 2em; zoom: 1; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;">可以占有写模式的读写锁, 但是可以有多个线程同时占有读模式的读写锁. 正是因为这个特性,</span></div><div style="font-size: 14px; overflow-wrap: break-word; margin-bottom: 15px; text-indent: 2em; zoom: 1; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; overflow-wrap: break-word; text-indent: 2em; zoom: 1; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;"> 2.当读写锁是写加锁状态时, 在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞.</span></div><div style="font-size: 14px; overflow-wrap: break-word; margin-bottom: 15px; text-indent: 2em; zoom: 1; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="font-size: 14px; overflow-wrap: break-word; text-indent: 2em; zoom: 1; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;"> 3.当读写锁在读加锁状态时, 所有试图以读模式对它进行加锁的线程都可以得到访问权, 但是如果线程希望以写模式对此锁进行加锁, 它必须直到所有的线程释放锁.</span></div><div><span style="font-size: 14px; overflow-wrap: break-word; text-indent: 2em; zoom: 1; letter-spacing: normal; orphans: 2; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 24px;">        4.通常, 当读写锁处于读模式锁住状态时, 如果有另外线程试图以写模式加锁, 读写锁通常会阻塞后面的读模式锁请求, 这样可以避免读模式锁长期占用, 而等待的写模式锁请求长期阻塞.</span></div><div><br/></div><div><br/></div><div>// 乐观锁和悲观锁</div><div><br/></div><div>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。   </div><div>            乐观锁适用于多读的应用类型，这样可以提高吞吐量</div><div>            应用案例： 数据库中 write_condition 机制</div><div><br/></div><div><br/></div><div>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，所以别人想拿这个数据就会阻塞。</div><div>            应用案例：数据库中行锁，表锁，读锁，写锁等</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 