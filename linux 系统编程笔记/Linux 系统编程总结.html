<html>
<head>
  <title>Linux 系统编程总结</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600240 (zh-CN, DDL); Windows/6.1.1 (Win32);"/>
  <meta name="application-data:QZONE_SHARE_FLAG" content="success,0,0,1548162342334"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1615"/>
<h1>Linux 系统编程总结</h1>

<div><span><div><div><div>1.Linux 下的基本命令</div><ol><li><div>ls</div></li><ol><li><div>语法： ls [选项] [目录或文件]</div></li><li><div>功能： 对于目录，列出该目录下的所有子目录 和 文件。 对于文件，列出文件名以及其他信息。</div></li><li><div>常用选项： </div></li><ol><li><div>-a 列出目录下的所有文件，包括 . 开头的隐含文件</div></li><li><div>-d 将目录像文件一样显示，而不是显示其下的文件</div></li><li><div>-i 输出文件 i 节点的索引信息</div></li><li><div>-n 用 UID, GID 代替文件所属名 和 文件所属组名</div></li><li><div>-r 对目录反向排序</div></li><li><div>-s 在显示文件名前面显示文件的大小</div></li></ol></ol><li><div>cd</div></li><ol><li><div>语法： cd 目录名</div></li><li><div>功能： 改变文件目录，将当前文件路径改为指定路径</div></li><li><div>举例：</div></li><ol><li><div>cd ~ 到家目录</div></li><li><div>cd -  返回最近访问目录</div></li></ol></ol><li><div>touch</div></li><ol><li><div>语法： touch [选项] 文件</div></li><li><div>功能： touch 命令参数可更改文档或目录的日期时间，包括存取时间 和 更改时间，或新建一个不存在的文件</div></li><li><div>常用选项： -a, -c, -d, -f, -m, -r , -t 等</div></li></ol><li><div>mkdir ： 在当前目录下创建一个名为 指定名称 的目录</div></li><li><div>rmdir / rm :  删除空目录 / 删除文件或目录</div></li><li><div>cp： 复制文件或目录</div></li><ol><li><div>说明： 如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到次目录。 如果目的地并非一个已经存在的目录，或出现错误信息。</div></li></ol><li><div>man</div></li><ol><li><div>-k 根据关键字搜索联机帮助</div></li><li><div>num 只在 num 章节找</div></li><li><div>-a 将所有章节都显示出来。 按下 q 之后，会继续往后面搜索，直到所有章节搜索完毕</div></li><li><div>man 手册 8 章：</div></li><ol><li><div>普通的命令</div></li><li><div>系统调用，如 open, write</div></li><li><div>库函数，如 printf, fread</div></li><li><div>特殊文件， /dev 下的各种设备文件</div></li><li><div>文件的格式， 如 passwfd, 说明这个文件中的各个字段的含义</div></li><li><div>给游戏留的，由各个游戏自己定义</div></li><li><div>附件还有一些变量，比如 environ 这种全局变量在这里有说明</div></li><li><div>系统管理用的命令，这些命令只能由 root 使用，如 ifconfig</div></li></ol></ol><li><div>mv：移动文件或为文件改名</div></li><li><div>cat / tac：查看目标文件内容</div></li><li><div>more：与 cat 类似</div></li><li><div>less：对文件或其它输出进行分页显示的工具。 （可以说是 Linux 正统查看文件内容的工具）</div></li><ol><li><div>less 与 more 类似，但是可以随意浏览文件，more 只能向前，less 可以向前，也可以向后，而且 less 在查看前不会加载整个文件。</div></li><li><div>/ 字符串： 向下搜</div></li><li><div>？ 字符串： 向上搜</div></li><li><div>-N ： 显示行号</div></li><li><div>-i：搜索忽略大小写</div></li></ol><li><div>head：显示文件头某个数量的文字块到标准输出中，默认是 10 行</div></li><li><div>tail：显示文件尾内容，不指定文件，作为输入信息处理。 -f 选项 循环读取</div></li><li><div>时间相关指令</div></li><ol><li><div>date ：指定格式显示时间</div></li><li><div>时间戳 ： date +%s</div></li><li><div>显示时间格式： date + %F 等</div></li><li><div>设置时间： date -s </div></li></ol><li><div>find：用于在文件树中查找文件，作相应处理</div></li><li><div>grep： 在文件中搜索字符串，将找到的行打印出来</div></li><li><div>zip / unzip：将目录或文件压缩 zip 格式</div></li><li><div>tar：打包/解包</div></li><ol><li><div>-c 建立一个压缩文件的参数指令</div></li><li><div>-x 解开一个压缩文件的参数指令</div></li><li><div>-v 压缩过程显示文件</div></li><li><div>-f 使用文档名， 在 f 后面直接跟文件名，不要在加参数</div></li><li><div>-C 解压到指定目录</div></li><li><div>-p 保留原本文件权限</div></li></ol><li><div>uname：用来获取电脑 和 操作系统的相关信息。 -a 选项，详细输出 所有信息，依次为： 内核名称，主机名，内核版本号，内核版本，硬件名，处理器类型，硬件平台类型，操作系统名称</div></li><li><div>关机 shutdown</div></li><ol><li><div>-h 将系统的服务停掉后立即关机</div></li><li><div>-r 将系统的服务停掉后重新启动</div></li><li><div>-t sec : -t 后面加秒数，过几秒关机</div></li></ol><li><div>权限相关</div></li><ol><li><div>chmod 设置文件的访问权限</div></li><ol><li><div>R ：递归修改目录文件的权限</div></li><li><div>说明： 只有文件的拥有者 和 root 才能修改文件的权限</div></li></ol><li><div>chown 修改文件的拥有者</div></li><li><div>chgrp 修改文件或目录的所属组</div></li><li><div>umask 查看或修改 文件掩码</div></li><ol><li><div>新建文件默认权限 =  0666 - 权限掩码</div></li><li><div>新建目录默认权限 =  0777 - 权限掩码</div></li></ol><li><div>file 指令 辨别文件类型</div></li><li><div>粘滞位（chmod +t）</div></li><ol><li><div>说明： 只能由 超级用户、该目录的拥有者、该文件的拥有者删除</div></li></ol></ol></ol><div><br/></div><hr/><div><br/></div><div>2.Linux 基础开发工具的使用</div><ol><li><div>vim 操作</div></li><li><div>gcc/g++使用</div></li><ol><li><div>选项：</div></li><ol><li><div>-E 只激活预处理，这个不生成文件，需要重定向到一个输出文件中</div></li><li><div>-S 编译到汇编语言</div></li><li><div>-c 编译到目标代码</div></li><li><div>-o 文件输出到文件</div></li><li><div>-static 对生成的文件采用静态链接</div></li><li><div>-g 生成调试信息</div></li><li><div>-share 使用动态库</div></li><li><div>-O（1-4）： 编译器优化选项的 4 个级别</div></li><li><div>-w 不生成任何警告信息</div></li><li><div>-Wall 生成所有警告信息</div></li></ol></ol><li><div>gdb 的使用 ： 编译时 加 -g 选项</div></li><ol><li><div>list/l 行号： 显示源代码，接着上次位置往下显示，每次显示 10 行</div></li><li><div>list/l 函数名： 显示某个函数的源代码，默认每次显示 10 行</div></li><li><div>r 或 run：运行程序</div></li><li><div>s 或 step：进入函数调用</div></li><li><div>break(b) 行号：在某一行设置断点</div></li><li><div>break 函数名：在某个函数开头设置断点</div></li><li><div>info break： 查看断点信息</div></li><li><div>finish：执行到当前函数返回，然后停下来等待命令</div></li><li><div>print(p)：打印变量值</div></li><li><div>set var：修改变量的 值</div></li><li><div>continue(c)：从当前位置开始连续而非单步执行程序</div></li><li><div>delete breakpoints：删除所有断点</div></li><li><div>delete breakpoints n：删除序号为 n 的断点</div></li><li><div>disable breakpoints：禁用断点</div></li><li><div>enable breakpoints：启用断点</div></li><li><div>display 变量名：跟踪查看一个变量，每次停下来都显示它的值</div></li><li><div>undisplay：取消对之前变量的跟踪</div></li><li><div>until x行号：调至 x 行</div></li><li><div>breaktrace(或 bt)：查看各级函数调用及参数</div></li></ol><li><div>make/Makefile</div></li><ol><li><div>make 会在当前目录下找名字 &quot;Makefile&quot; 或 &quot;makefile&quot;的文件；</div></li><li><div>如果找到，会寻找第一个目标文件，假定 hello；</div></li><li><div>如果 hello 不存在，或 hello 所依赖的文件的文件 hello.o 修改时间比现有的文件 hello 新（可用 touch 测试），那么执行后面所定义的命令生成 hello 文件</div></li><li><div>如果所依赖的文件 hello.o 不存在， make 会在当前文件中找目标为 hello.o 文件的依赖，如果找到，根据规则生成 hello.o 文件</div></li><li><div>如果源文件存在 生成 hello.o 文件，然后再用 hello.o 文件声明 make 的最后任务，就是执行 hello 文件了。</div></li><li><div>以上就是 make 的依赖性；</div></li><li><div> 找寻过程中如果出错，比如 最后一个依赖文件找不到， make 直接退出并报错，对于所定义命令的错误，或者编译不成功， make 不管</div></li><li><div>make 只管文件的依赖性，如果找到依赖关系，冒号后面的文件不在，make 就退出报错。</div></li><li><div>可以设置伪目标，伪目标的特性是： 总是被执行的。</div></li></ol><li><div>软件包管理器 yum</div></li><ol><li><div>yum list 可以罗列当前有哪些软件包</div></li><li><div>安装软件 sudo yum install</div></li><li><div>卸载软件 sudo yum remove</div></li><li><div>更新 yum 源：</div></li><ol><li><div>备份默认的软件源配置文件（/etc/yum.repos.d/），便于恢复系统。</div></li><li><div>替换 CentOS-Base.repo 内容</div></li><li><div>文件保存后执行 yum makecache </div></li></ol></ol></ol><hr/><div><br/></div><div>3.Linux 进程</div><div>操作系统管理硬件： 先描述，后组织</div><ol><li><div>进程基本概念</div></li></ol><ol start="3"><ol><li><div>概念：程序的一个执行实例，正在执行中的程序</div></li><li><div>task_struct （PCB 的一种）包含：</div></li><ol><li><div>标识符：描述进程的唯一标识符</div></li><li><div>状态： 任务状态，退出代码，退出信号等。</div></li><li><div>优先级：相对于其他进程的优先级</div></li><li><div>程序计数器：程序中即将被执行的下一条指令的地址。</div></li><li><div>内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针</div></li><li><div>上下文数据：进程执行时处理器寄存器中的数据</div></li><li><div>其他</div></li></ol><li><div>创建进程</div></li><ol><li><div>fork()</div></li><ol><li><div> 两个返回值，为 0 ，表示子进程， 非零表示父进程</div></li><li><div>通常需要 if 进行分流</div></li><li><div>父子进程交替进行</div></li><li><div>如果父进程先退出，子进程变成孤儿进程</div></li><li><div>父子进程共享数据区： 写时拷贝（有一方修改触发）</div></li><li><div>子进程先退出，父进程没有及时回收，子进程变成僵尸进程</div></li></ol><li><div>父子进程：</div></li><ol><li><div>子进程会继承父进程哪些内容？答：进程上下文，内存信息，文件描述符，进程调度优先级，信号设置等</div></li><li><div>子进程与父进程有哪些区别？ </div></li><ol><li><div>fork( ) 的返回值不同；</div></li><li><div>父进程的锁子进程不继承；</div></li><li><div>父进程的 ID 子进程不继承；</div></li><li><div>父进程的未决信号子进程清除。</div></li></ol></ol></ol><li><div>进程状态</div></li><ol><li><div>7 种状态： R（运行态）, S（可中断睡眠）, D（不可中断睡眠）, T（停止态）,  t（跟踪态）, X（死亡状态）, Z（僵尸态）</div></li><li><div>僵尸进程：子进程退出，父进程没有读取子进程的状态。 僵尸态的进程会导致资源占用，内存泄漏。</div></li><li><div>孤儿进程：父进程退出，子进程还没有退出，子进程变成孤儿进程。</div></li></ol><li><div>进程优先级</div></li><ol><li><div>cpu 资源分配的先后顺序，指的是进程的优先权。</div></li><li><div>ps -l //查看系统进程：</div></li><ol><li><div>PRI 所指的就是进程优先级，此值越小优先级别越高，越先被执行</div></li><li><div>NI 表示 nice 值，可对优先级进行修改， PRI(new) = PRI(old) + nice。 nice 取值范围： -20 ~19</div></li><ol><li><div>启动时指定： nice -n -5 ./main </div></li><li><div>调整已存在进程 nice：renice --&gt; renice -5 -p 5200//将PID为 5200 的进程 nice 设为 -5。</div></li><li><div>top 更改已存在进程 nice： 进入 top 后按 &quot;r&quot; -&gt;输入进程 PID -&gt; 输入 nice 值。</div></li></ol></ol></ol><li><div>环境变量</div></li><ol><li><div>概念： 操作系统中用来指定操作系统运行环境的一些参数</div></li><li><div>相关命令：</div></li><ol><ol><li><div>echo 显示指定的环境变量值 ,  </div></li></ol><li><div>export  设置一个新的环境变量</div></li><li><div>env  显示所有的环境变量</div></li><li><div>unset  清除环境变量</div></li><li><div>set  显示本地定义的 shell 变量 和 环境变量</div></li></ol><li><div>环境变量具有全局属性， 可被子进程继承</div></li></ol><li><div>进程地址空间</div></li></ol><li><div>进程控制</div></li><ol><li><div>进程创建 </div></li><li><div>进程终止</div></li></ol><ol><li><div>从 main 函数返回</div></li><li><div>调用 exit</div></li><ol><li><div>执行用户通过 atexit 或 on_exit 定义的清理函数</div></li><li><div>关闭所有打开的流，所有的缓存数据均被写入</div></li></ol><li><div>调用_exit </div></li><li><div>_exit</div></li><li><div>异常终止 </div></li></ol></ol><div>                3. 进程等待</div><div>                            1. 方法 wait / waitpid</div><div>                                    1. 如果子进程退出，调用 wait/waitpid，会立即返回，并释放资源，获得子进程退出的信息</div><div>                                    2.如果在任意时刻调用 wait/waitpid，子进程存在且正常运行，则进程可能阻塞</div><div>                                    3.如果不存在该进程，则立即出错返回。</div><div>                            2.获取子进程 status</div><div>                                    1.wait/waitpid 的 status 参数，为 NULL，不关心，否则，该参数将子进程退出信息反馈给父进程      </div><div>                                    2.status 看作一个位图，高 8 位存正常退出的状态码，低 7 位存异常退出码，中间一位 coredump 标志</div><div>                 4. 进程程序替换</div><div>                            exec 族函数理解：</div><ol><li><div>exec 函数只有出错的返回，没有成功的返回值</div></li><li><div>l( list )：表示参数采用列表</div></li><li><div>v( vector )：表示参数采用数组</div></li><li><div>p( path )：表示 自动搜索环境变量 PATH</div></li><li><div>e( env )：自己维护环境变量  </div></li></ol><ol start="4"><li><div>进程间通信</div></li><ol><li><div>目的：数据传输、资源共享、通知事件、进程控制 </div></li><li><div>分类： 管道、消息队列、共享内存、信号量、socket、互斥量、条件变量等</div></li><li><div>管道：（匿名管道 pipe 和 命名管道 mkfifo）</div></li><ol><li><div>概念：把从一个进程到另一个进程的一个数据流称为一个“管道”。</div></li><li><div>读写规则： </div></li><ol><li><div>O_NONBLOCK disable: 如果缓冲区空，read 调用阻塞，等待数据，如果缓冲区满，write 调用阻塞，直到有进程读走数据。</div></li><li><div>O_NONBLOCK able：如果缓冲区空， read 返回 -1, 如果缓冲区满，write 返回 -1， errno 均为 EAGIN。</div></li><li><div>如所有管道的写端对应文件描述符被关闭， read 返回 0</div></li><li><div>如所有管道的读端对应文件描述符被关闭， write 产生 SIGPIPE 信号，进而可能导致 write 退出</div></li><li><div>当写入的数据量不大于 PIPE_BUF 时， linux 将保证写入的原子性</div></li><li><div>如果写入数据量大于 PIPE_BUF， linux 不保证写入的原子性。</div></li></ol><li><div>特点：</div></li><ol><li><div>只能用于具有亲缘关系的进程之间的通信；</div></li><li><div>提供的是 流式服务； 流式服务： 体现的是数据的发送和接收的灵活性，数据没有边界，容易粘包（多条数据连到一起，无法分清数据的界限）</div></li><li><div>一般进程退出，管道释放，生命周期随进程；</div></li><li><div>一般内核会对管道操作进行同步与互斥</div></li><li><div>管道是半双工通信，需要双方通信，建立两个管道</div></li></ol></ol><li><div>消息队列</div></li><ol><li><div>概念：消息队列提供了一个从一个进程向另一个进程发送一块数据的方法</div></li><li><div>不足：</div></li><ol><li><div>每个消息的最大长度有上限 MSGMAX</div></li><li><div>每个消息队列的总字节数也有上限 MSGMNB</div></li><li><div>系统上消息队列的总数也有上限 MSGMNI</div></li></ol><li><div>消息队列函数 ： msgget（创建）、msgctl（控制函数）、msgsnd（发送信息）、msgrecv（接收信息）</div></li></ol><li><div>共享内存</div></li><ol><li><div>介绍：最快的 IPC 形式。 一旦内存映射到共享 它的进程地址空间中，这些进程间的数据传递不再涉及内核。</div></li><li><div>共享内存函数： shmget（创建）、shmat（将内存挂载到进程地址空间）、shmdt（从当前进程卸载共享内存，不等同于删除共享内存）、shmctl（控制共享内存）</div></li></ol></ol><li><div>进程关系 和 守护进程</div></li><ol><li><div>进程组： 一个或多个进程的集合</div></li><ol><li><div>组长进程： 每个进程组都有一个唯一的进程组 ID，进程组 ID 等于组长 ID。</div></li><li><div>只要进程组中有一个进程存在，该进程组就存在，与组长进程存在与否无关。</div></li></ol><li><div>作业</div></li><ol><li><div>shell 分前后台控制的不是进程而是 进程组 或 作业。</div></li><li><div>作业 与 进程组的区别： 如果祖业中的某个进程有创建了子进程， 子进程不属于作业。</div></li><li><div>相关命令： jobs 查看当前有哪些作业。 fg 将某个作业提到前台执行</div></li></ol><li><div>会话（SID）</div></li><ol><li><div>概念：一个或多个进程组的集合。</div></li><li><div>一个会话包括： 控制进程（会话首进程），一个前台进程组 和 任意多个后台进程组。</div></li></ol><li><div>守护进程</div></li><ol><li><div>运行在后端的一种特殊进程。 它独立于控制终端周期性的执行某个任务或等待处理某些发生的事件。</div></li><li><div>ps axj 查看系统中的进程</div></li><ol><li><div>a 表示不仅列出当前用户的进程，也列出所有其他用户的进程</div></li><li><div>x 表示不仅列出有控制终端的进程，也列出无控制终端的进程</div></li><li><div>j 列出与作业控制相关的信息</div></li><li><div>凡是 TPGID 栏写着 -1 的都是守护进程</div></li><li><div>COMMEND 列中 []括起来的表示内核进程，通常以 k 开头 Kernel</div></li><li><div>守护进程通常以 d 结尾，Daemon</div></li></ol><li><div>创建守护进程：</div></li><ol><li><div>setsid 创建一个新的 Session，称为 Session Leader</div></li><ol><li><div>注意调用 setsid 之前，当前进程不允许是进程组组长，否则出错返回 -1.</div></li><li><div>可以先 fork( ) ，再用子进程调用</div></li></ol></ol></ol></ol></ol><div>    </div><hr/><div><br/></div><div>4.Linux 基础 I/O </div><ol><li><div>FILE （/usr/include/stdio.h）</div></li><ol><li><div>一般的 C 库函数写入文件中都是全缓冲的，而写入显示器是行缓冲的。</div></li><li><div>printf fwrite 自带缓冲区，当发生 重定向到普通文件，数据缓冲方式编程了全缓冲</div></li><li><div>放在缓冲区中的数据不会立即刷新，如果调用 fork 可能会出现数据被写入两次（缓冲区刷新可能在 fork( ） 之后）</div></li><li><div>但是进程退出，会统一刷新</div></li></ol><li><div>文件系统</div></li><ol><li><div>创建文件主要的 4 个步骤</div></li><ol><li><div>存储属性：找空闲的 i 节点。内核把文件信息记录其中</div></li><li><div>存储数据：找空闲的磁盘块，进行数据存储</div></li><li><div>记录分配情况： 内核在磁盘分布区记录了文件内容对应的存放块列表</div></li><li><div>添加文件名到目录： 内核将 文件名 对应的入口添加到目录文件。</div></li></ol><li><div>硬链接 和 软链接</div></li><ol><li><div>软链接可以跨文件系统，硬链接不可以</div></li><li><div>软链接可以指向目录，硬链接不允许</div></li><li><div>如果删除源文件，软链接不能再访问到源文件，硬链接可以</div></li><li><div>软链接有自己的 inode 节点号，硬链接与源文件相同</div></li></ol><li><div>动态库 和 静态库</div></li><ol><li><div>静态库：程序在链接是把库的代码链接到可执行文件中。程序运行时不在需要静态库。</div></li><li><div>动态库：程序在运行的时候才去链接动态库的代码，多个程序共享使用库的代码。</div></li></ol></ol></ol><hr/><div><br/></div><div>5.信号</div><ol><li><div>产生信号的方式</div></li><ol><li><div>用户通过按下某些键之后，由终端驱动程序发送给前台进程；比如， ctrl + c</div></li><li><div>硬件异常产生信号； 比如， 进程执行 除以 0 的指令， 进程访问了非法内存等</div></li><li><div>进程调用 kill 函数发送信号给一个进程；</div></li><li><div>软件条件产生； SIGPIPE</div></li></ol><li><div>处理信号的方式</div></li><ol><li><div>忽略此信号</div></li><li><div>执行信号的默认处理动作</div></li><li><div>提供一个默认信号处理函数。要求内核在处理该信号时切换到用户态执行这个处理函数，称为捕捉一个信号。</div></li></ol><li><div> pause 函数</div></li><ol><li><div>pause 函数使调用进程挂起直到有信号递达。</div></li><li><div>如果信号的处理动作是终止进程，则进程终止，pause 函数没有返回的机会；</div></li><li><div>如果信号的处理动作是忽略，进程继续处于挂起状态，pause 函数不返回；</div></li><li><div>如果信号的处理动作是捕捉，则调用了子进程的信号函数后 pause 返回 -1， errno 设置成 EINTR， EINTR 表示“被信号中断”。</div></li><li><div><span style="font-weight: bold;">所以 pause 只有出错的返回。 之前 的 exec 系列函数也是只有出错的返回</span>。  </div></li></ol><li><div>可重入 和 不可重入</div></li><ol><li><div>如果一个函数只访问自己的局部变量或参数，称为可重入函数</div></li><li><div>不可重入：</div></li><ol><li><div>调用了 malloc 或 free,因为 malloc 也是用全局链表来管理堆的；</div></li><li><div>调用了标准 I/O 库函数。标准 I/O 库函数很多实现都以不可重入的方式使用全局数据结构。</div></li></ol><li><div>volatile 限定符</div></li><ol><li><div>要求编译器每次都要从内存中读取 volatile 关键字所限定的变量。</div></li><li><div>属于以下的情况之一的需要 用到 volatile</div></li><ol><li><div>变量的内存单元的数据不需要写操作就可以自己发生变化，每次读上来的值都有可能不同；比如，串口的接收寄存器</div></li><li><div>即使多次向变量的内存单元写数据，只写不读，也并不是做无用功， 映射到内存地址空间的硬件寄存器。比如，发送寄存器</div></li></ol></ol><li><div>附记： sig_atomic_t 类型的变量，在不同的 C 语言库中取不同的的类型，比如，在 32 位机上 sig_atomic_t 为 int 类型。 使用 sig_atomic_t 变量应该加上 volatile 限定符。</div></li></ol><li><div>竞态条件</div></li><ol><li><div>概念：由于异步事件可能在任何时刻发生（这里异步指更高优先级进程），如果程序考虑不周密，造成由于时序问题而导致错误。</div></li><li><div>解决竞态条件: sigsuspend 函数</div></li><ol><li><div>sigsuspend 函数没有成功返回；</div></li><li><div>只有执行了一个信号处理函数之后 才会返回，返回值 -1， errno 为 EINTR。</div></li></ol></ol></ol><div><br/></div><hr/><div><br/></div><div>6.线程</div></div><ol><li><div>概念：程序里的一个执行路线， 一个进程至少有一个线程</div></li><li><div>进程 与 线程：</div></li><ol><li><div>进程是资源分配的基本单位；</div></li><li><div>线程是程序调度的基本点位；</div></li><li><div>线程共享进程的数据， 也有自己一部分数据： 线程 ID 、寄存器、栈、errno、信号屏蔽字、调度优先级。</div></li><li><div>创建线程的代价要比创建进程小的多；</div></li><li><div>线程切换消耗小；</div></li><li><div>线程能充分利用 多处理器的可并行数量；</div></li><li><div>线程可以同时等待不同的 I/O 操作</div></li></ol><li><div>同一个进程中的线程之间共享：</div></li><ol><li><div>同一地址空间，即 text segement、data segement 都是共享；</div></li><li><div>文件描述符表</div></li><li><div>每种信号的处理方式</div></li><li><div>当前工作目录</div></li><li><div>用户 id 和 组 id。</div></li></ol><li><div>线程的缺点：</div></li><ol><li><div>性能缺失： 如果计算密集型的线程无法与其他线程共享同一个处理器，如果线程数量比处理器数量多的时候，可能有较大的性能损失，因为增加了额外的同步与调度开销。 但是可用的资源不变。</div></li><li><div>健壮性降低： 在多线程的程序中，因时间分配的细微偏差或共享了变量而造成错误的可能性很大，线程之间是缺乏保护的。</div></li><li><div>缺乏访问控制： 进程是访问控制的基本单位，在一个线程中调用某些 OS 函数会对整个进程造成影响。</div></li><li><div>编程难度提高。</div></li><li><div>线程控制： POSIX  线程库</div></li></ol><li><div>创建线程 pthread_create （该函数返回的线程 ID 是 Linux 中 NPTL 中的线程）， 可通过 pthread_self 获取线程自身 ID ， pthread_t 本质是进程地址空间上的一个地址。</div></li><ol><li><div>以下的线程 ID 说的是 进程调度范畴。 线程是轻量级进程，需要一个数值来唯一标识它</div></li><ol><li><div>Linux 中提供 gettid 来返回线程 ID ， 但是 glibc 没有将该系统调用封装。  </div></li><li><div>使用 ps -eLf 查看， 加上表头 ps -eLf | head -l ，其中 LWP 是线程 ID, 也是 gettid( ) 系统调用返回的值， NLWP 是线程组中线程的个数。</div></li><li><div>可以使用 tid = syscall(SYS_gettid); 获取线程 ID。</div></li></ol></ol><li><div>线程终止（只终止某个线程而不终止整个进程）</div></li><ol><li><div>从线程函数 return。 对主线程不适用，从 main 函数 return ,相当于调用 exit;</div></li><li><div>线程可以调用 pthread_exit 终止自己；</div></li><li><div>一个线程可以调用 pthread_cancel 终止同一个进程中的另一个线程。</div></li><li><div>注意： pthread_exit 或者 return 返回的指针所指向的内存单元必须是全局的或者 malloc 分配的，不能在线程函数的栈上分配。</div></li></ol><li><div>线程等待与分离</div></li><ol><li><div>线程等待 pthread_join 函数： 不同的终止，返回给第二个参数终止状态不同</div></li><ol><li><div>return 返回： 从在线程函数的返回值；</div></li><li><div>pthread_exit： 传给 pthread_exit 的参数；</div></li><li><div>pthread_cancel：常数 PTHREAD_CANCELED；</div></li><li><div>如果对返回值不感兴趣， 第二个参数为 NULL。</div></li></ol><li><div>线程分离 pthread_detach 函数</div></li><ol><li><div>线程分离设置之后，当线程退出时，自动释放线程资源</div></li><li><div>如果不关心线程的返回值，可以使用该函数指定某个线程分离，也可以指定自身</div></li></ol></ol><li><div>线程同步与互斥</div></li><ol><li><div>互斥量 mutex</div></li><ol><li><div>静态分配： pthread_mutex mutex = PTHREAD_MUTEX_INITIALIZER</div></li><li><div>动态分配： pthread_mutex_init 函数</div></li><li><div>注意：</div></li><ol><li><div>静态分配出的互斥量不需要销毁</div></li><li><div>不要销毁已加锁的互斥量</div></li><li><div>已经销毁的互斥量，不可以再用来加锁</div></li></ol></ol><li><div>条件变量 cond</div></li><ol><li><div>pthread_cond_init 初始化</div></li><li><div>pthread_cond_wait 等待条件满足， 注意这里等待要使用 死循环的方式等待 while</div></li><li><div>pthread_cond_broadcast  和 pthread_cond_signal  用来唤醒等待</div></li><li><div>注意， pthread_cond wait 需要用到互斥量， 必须使得解锁和等待是一个原子操作。</div></li></ol><li><div>POSIX 信号量 sem</div></li><ol><li><div>POSIX 信号量 与 System V 信号量都是用于同步。 但 POSIX 信号量可用于线程间同步</div></li><li><div>sem_init 第<span style="font-weight: bold;"> </span><span style="color: rgb(227, 0, 0); font-weight: bold;">二</span><span style="font-weight: bold;"> </span>个参数为 0，线程间同步，非零，进程间同步</div></li></ol><li><div>sem_wait 等待信号量  sem_post 发布信号量 </div></li><li><div>读写锁</div></li><li><div>乐观锁</div></li><li><div>悲观锁</div></li></ol></ol></div><div><br/></div></span>
</div></body></html> 