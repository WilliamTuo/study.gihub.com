<html>
<head>
  <title>信号</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600240 (zh-CN, DDL); Windows/6.1.1 (Win32);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="546"/>
<h1>信号</h1>

<div>
<span><div><div><br/></div><div>mmap    《UNIX系统编程手册》</div><div><br/></div><div>信号：    通知事件的发生，不是第一时间处理，而是存储下来  </div><div>        在程序正常执行过程中可能出现一个情况，linux可以响应这些异常情况，当异常情况来了以后， 我们的程序就要执行相应的动作。</div><div><br/></div><div>产生信号：</div><div>        非法内存访问</div><div>        硬件故障</div><div>        浮点数溢出</div><div>        ctrl + c</div><div><br/></div><div>信号源：</div><div>        1.硬件</div><div>        2.软件</div><div><br/></div><div>查看系统有哪些信号</div><div>        kill -l</div><div>        </div><div>        SIGHUP: 关闭终端</div><div>        SIGINT : ctrl + c</div><div>        SIGQUIT : ctrl + \</div><div>        SIGABRT:  abort();使进程异常终止</div><div>        SIGFPE : 浮点数溢出</div><div>        SIGKILL: 杀死进程</div><div>        SIGSEGV: 段错误</div><div>        SIGPIPE: 管道破裂</div><div>        SIGALRM： 闹钟信号</div><div>        SIGTERM： 终止进程</div><div>        SIGCHLD : 子进程死亡</div><div>        SIGIO : 异步IO</div><div>                </div><div>进程收到信号的三种响应</div><div>        忽略信号     不能忽略SIGKILL SIGSTOP</div><div>        捕获并处理    不能捕获SIGKILL SIGSTOP</div><div>        缺省处理        缺省处理到底执行什么动作，详见 man 7 signal</div><div><br/></div><div><br/></div><hr/><div><br/></div><div><br/></div><div>//<span style="font-weight: bold;">信号处理函数执行期间，屏蔽本信号，但是不会屏蔽其他信号</span></div><div>//注册信号功能相对 signal 强大， 可以屏蔽其他信号， 可以传递数据， 可以设置信号重启时间</div><div><br/></div><div><br/></div><div>int sigaction(int signum,   //信号</div><div>                     const struct sigaction *act,    //信号处理函数</div><div>                     struct sigaction *oldact);   //NULL</div><div><br/></div><div>struct sigaction {</div><div>               void     (*sa_handler)(int);</div><div>               //void     (*sa_sigaction)(int, siginfo_t *, void *); </div><div>               sigset_t   sa_mask;   //信号处理函数执行期间的信号屏蔽（可用来屏蔽其他函数）</div><div>               int        sa_flags;  //0</div><div>               //void     (*sa_restorer)(void);</div><div>           };</div><div><br/></div><hr/><div><br/></div><div>typedef void (sighandler_t)(int)</div><div>安装信号（注册信号）：</div><div>        void (*signal(int signo,     //要注册的信号编号</div><div>                    void (*handler)(int))) (int);    //handler 信号处理函数</div><div><br/></div><div>typedef void  (*handler)(int) h;</div><div>handler singnal(int signo, handler h); </div><div><br/></div><div>            #define  SIG_IGN(sighandler_t)(0))  //忽略</div><div>            #define  SIG_DFL(sighandler_t)(1))    //缺省</div><div>            #define  SIG_ERR(sighandler_t)(-1))    //返回错误</div><div>    signal(SIGINT, SIG_IGN);</div><div><br/></div><div>        返回值： 旧的信号处理函数，</div><div><br/></div><div><span style="font-weight: bold;">信号的分类：</span></div><div><span style="font-weight: bold;">        1.可靠信号和不可靠信号</span></div><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">       </span> 不可靠信号表现在：</div><div>                    （1）当执行完信号处理函数后，恢复成缺省处理动作（linux已解决，其它：再注册一次）</div><div>                    （2）当多个信号同时抵达，可能出现信号丢失</div><div>            1~31 号： 不可靠</div><div>            34~64 号：可靠</div><div>            32、33被C函数用来做多线程</div><div><br/></div><div><span style="font-weight: bold;">        2.实时信号和非实时信号</span></div><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">    </span><span style="font-weight: bold;">   </span> 34~64：实时信号</div><div>            实时信号都是可靠信号</div><div>            非实时信号都是非可靠信号</div><div><br/></div><div><span style="font-weight: bold;">发送信号：</span></div><div>        kill    命令</div><div>                kill -信号值 pid</div><div>                kill all -信号值 name 给所有叫nam的进程发送信号</div><div>                信号值缺省是15号</div><div><br/></div><div>        kill函数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>int kill(pid_t pid,  //给哪个信号发送信号</div><div>           int signo);  //发送什么信号</div></div><div>pid:  </div><div>    如果大于0： 发送给指定信号</div><div>    如果等于0： 发送给本进程组信号</div><div>    如果等于-1： 发送给本进程有权发送的任何一个进程       </div><div><span style="font-weight: bold;">   </span> 如果小于-1： 发送给|pid|进程组的任何一个进程</div><hr/><div>进程组： 管道连接的多个进程属于同一个进程组， （第一个进程的pid是进程组的pid）， fork出来，父子进程属于同一个进程组（父进程的pid是进程组的pid）。</div><div><br/></div><div>sleep 100 &amp;     以后台的方式启动进程</div><div>ctrl + c 只能给前台进程组</div><div><br/></div><div>jobs 查看有哪些后台作业</div><div>fg %作业号：  将后台的作业拿到前台</div><div><br/></div><div>pause()  //将当前进程置为可中断的睡眠状态，然后调用schedule(),使linux进程调度算法找到另外一个进程来执行。</div><div>        pause使调用者进程一直挂起，直到有信号被捕捉</div><div><br/></div><div><br/></div><hr/><div>    SIGALRM</div><div>         int alarm(int sec);</div><div>                    sec:等sec秒过后，信号SIGALRM抵达 ，</div><div>如果为0, 清除之前的定时器信号，返回上一次定时器剩余的时间</div><div>       </div><div><br/></div><div>         定时器            </div><div>        int settimer(int which,   //ITMER_REAL</div><div>                        const struct itmerval *val,  //</div><div>                        struct itimerval *old); </div><div>    </div><div>           struct itimerval {</div><div>               struct timeval it_interval; /* next value */以后每次间隔时间</div><div>               struct timeval it_value;    /* current value */第一次启动时间</div><div>           };</div><div><br/></div><div>           struct timeval {</div><div>               long tv_sec;                /* seconds */秒</div><div>               long tv_usec;               /* microseconds */微秒</div><div>           };</div><div><br/></div><div>        </div><div>    ITMER_REAL:真实时间，到时间后产生SIGALRM信号</div><div>    ITIMER_VIRTUAL：虚拟时间（用户模式下的CPU时间）。到时间后会产生SIGVTALARM信号</div><div>    ITIMER_PROF:进程时间（用户态和内核态CPU时间总和）。到时间后会产生SIGPROF信号</div><div><br/></div><div>    signalfd();把任何信号转换为文件描述符</div><div><br/></div><div>    SIGCHLD:当子进程变成僵尸进程，操作系统会给父进程发送此信号</div><div>                    缺省处理是忽略，但是不会处理僵尸进程</div><div>                    我们捕获并告诉系统SIG_IGN,子进程死亡，不会产生僵尸进程</div><div>    signal(SIGCHLD, SIG_IGN)</div><div><br/></div><hr/><div>    </div><div>可重入和不可重入函数</div><div><span style="font-weight: bold;">不可重入函数： </span></div><div>    函数内部存在：</div><div>        1.操作了全局（静态）变量</div><div>        2.调用malloc（底层使用了链表）和free</div><div>        3.调用了标准IO 例如： printf()。</div><div><br/></div><div><span style="font-weight: bold;">可重入</span>： man 7 signal  查看</div><div>            很多， 例如： _Exit()  _exit()</div><div>                                   abort()</div><div>                                   accept()</div><div>                                   access()</div><hr/><div><br/></div><div><span style="font-weight: bold;">信号的内核表示</span></div><div>        递达： 执行信号的处理动作称为信号的递达(delivery)</div><div>                    </div><div>        未决：从信号的产生到信号的递达之间的状态称为未决（pending）</div><div><br/></div><div>    进程可以阻塞（block）信号，被阻塞的信号产生时，一直处于未决状态，直到该进程解除对该信号的阻塞，才执行递达动作。</div><div><br/></div><div><br/></div><div>    sigprocmask(int how, const sigset_t *set, int sigset_t *old); //用于信号阻塞</div><div>    how:</div><div>                SIG_BLOCK   :        mask |= *set </div><div>                SIG_UNBLOCK :     mask &amp;= ~(*set)</div><div>                SIG_SETMASK :      mask = *set</div><div>    </div><div>    mask : 内核中原来阻塞队列的值    </div><div>    set: 要设置的集合</div><div>    oldset: 返回旧的信号屏蔽集合</div><div><br/></div><div>    </div><div>    sigpending (sigset_t *set);   //获取内核的未决状态集</div><div><br/></div><div><br/></div><div>      </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"> #include &lt;signal.h&gt;</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        //清空信号集</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       int sigemptyset(sigset_t *set);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                memset(set, 0x00, sizeof(*set));</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        }        </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        //填充，将所有的信号添加到信号集中</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       int sigfillset(sigset_t *set);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                memset(set, 0xFF, sizeof(*set));</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        }</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div>    //将某一个信号加入信号集</div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       int sigaddset(sigset_t *set, int signum);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                (*set) |= (1 &lt;&lt; (signum -1));</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        }</span></div><div><br/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        //将某一个信号从信号集中删除</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       int sigdelset(sigset_t *set, int signum);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        {</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                (*set) &amp;= ~(1 &lt;&lt; (signum -1));</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        }</span></div><div><br/></div><div>    //判断一个信号是不是在信号集中</div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       int sigismember(const sigset_t *set, int signum);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        ｛</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                return ((*set) &amp; (1 &lt;&lt; (signum - 1))) == 0 ? 0 : 1;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">        ｝</span></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-weight: bold;">竞态 ： 跟时间有关的错误</span></div><div><br/></div><div>pause( void ); // 将当前进程挂起，转存储调度，直到有信号抵达，才唤醒该进程</div><div>    </div><div>int sigsuspend(const sigset_t *mask);   //加强版pause</div><div>        pause + 信号屏蔽（覆盖原有的信号）</div><div>sigsuspend 是等待信号处理函数执行完了之后才会返回</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 