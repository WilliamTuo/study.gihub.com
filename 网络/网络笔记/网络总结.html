<html>
<head>
  <title>网络总结</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600240 (zh-CN, DDL); Windows/6.1.1 (Win32);"/>
  <meta name="application-data:QZONE_SHARE_FLAG" content="success,0,0,1548162683288"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1617"/>
<h1>网络总结</h1>

<div><span><div><div><div>1.网络基础 </div><ol><li><div>OSI 七层参考模型：</div></li><ol><li><div>主要功能：帮助不同类型的主机实现数据传输</div></li><li><div>优点：将服务、接口 和 协议 三个概念明确的区分出来，概念清楚，理论比较完整。</div></li><li><div>缺点： 复杂不实用</div></li><li><div>包括：</div></li><ol><li><div>应用层：针对特定应用的协议</div></li><li><div>表示层：设备固有数据格式和网络标准数据格式的转换</div></li><li><div>会话层：通信管理，负责建立和断开通信连接， 管理传输层以下的分层</div></li><li><div>传输层：管理两个节点之间的数据传输。负责可靠传输</div></li><li><div>网络层：地址管理 和 路由选择</div></li><li><div>数据链路层：互连设备之间传送 和 识别数据帧</div></li><li><div>物理层：界定连接器 和 网线的 规格</div></li></ol></ol><li><div>TCP/IP 五层模型：</div></li><ol><li><div>物理层：负责光电信号的传递方式</div></li><li><div>数据链路层：负责设备之间的数据帧传送 和 识别</div></li><li><div>网络层：负责地址管理 和 路由选择</div></li><li><div>传输层：负责主机之间的数据传输。</div></li><li><div>应用层：负责应用程序之间的沟通</div></li></ol><li><div>TCP / UDP</div></li><ol><li><div>TCP：有连接、可靠传输、面向字节流</div></li></ol><ol><ol><li><div>确认应答机制： TCP 将每个字节的数据都进行了编号（序列号），每个 ACK 都带有对应的确认序列号，告诉发送者，已接受到的数据，下次从哪里开始传输。</div></li><li><div>超时重传机制： </div></li><ol><li><div>如果发送端在一个特定的时间间隔内没有收到接收端发来的确认应答，就进行重发。</div></li><li><div>如果是接收端发来的 ACK 丢了，通过序列号可以做到去重的效果</div></li><li><div>超时时间的确定： 为了保证高性能的通信，会动态计算这个最大超时时间； Linux 中以 500ms 为一个单位进行控制，每次判定超时重发的时间都是 500ms 的整数倍，如果重发得不到应答，等待 2 的指数级乘以 500 ms 进行重传，累计到一定次数， TCP 认为网络 或 接收端异常，强制关闭连接。</div></li></ol><li><div>滑动窗口（发送方）：可以一次发送多条数据，来提高传输效率。 </div></li><ol><li><div>协议头中的 窗口大小体现的是对方的接收缓冲区剩余的大小</div></li><li><div> 操作系统为了维护这个滑动窗口，需要开辟发送缓冲区来记录当前缓冲区有哪些数据没有应答，确认应答后的数据在会被删掉</div></li><li><div>窗口越大，网络吞吐率越高；</div></li><li><div>如果出现丢包：</div></li><ol><li><div>数据包抵达， ACK 丢了： 部分 ACK 丢了不要紧，可以通过后续的 ACK 进行确认</div></li><li><div>数据包丢了： 当某段数据丢失，接收端会发送多个同样的 ACK，提醒发送端发送指定的数据包； 如果发送端连续三次收到同样的 ACK，就会重发 ACK 指定的数据包； 再次收到的 ACK 是后面已经接收的报文段的下一个需要发送的报文段。（也叫 “快重传”）</div></li></ol></ol><li><div>流量控制： 用来根据接收端的处理能力，决定发送端的发送速度</div></li><ol><li><div>接收端处理数据的速度是有限的，如果发送端发送的太快，会导致接收端缓冲区溢出造成丢包；</div></li><li><div>接收端的接收缓冲区的大小放在 TCP 首部中的 “窗口大小”的位置通过 ACK 告诉发送端；</div></li><li><div>接收端根据实际接收中的处理速度不断的告诉发送端接收缓冲区的大小，以此来控制发送端的传输速度；</div></li><li><div>实际上接收端的缓冲区最大不是 16 位窗口大小最大所能表示的，在 TCP 首部 40 字节选项中，包含一个窗口扩大因子 M，表示实际大小是窗口字段的值左移 M 位。</div></li></ol><li><div>拥塞控制：根据实际传输过程中网络状态， TCP 引入慢启动机制，先发少量的数据，查看网络的状态，再决定传输速度</div></li><ol><li><div>拥塞窗口（网络）： 开始发送时，为 1； 每次收到一个 ACK ，拥塞窗口值+1，发送的时候将拥塞窗口 和 反馈的值作比较，取较小值作为实际发送的窗口。</div></li><li><div>慢启动的阈值： </div></li><ol><li><div>拥塞窗口的值开始是 以指数级增长，但是如果超过该阈值，就按线性增长；</div></li><li><div>开始传输时，阈值等于窗口最大值；</div></li><li><div>每次超时重传，阈值会变成原来的一半，同时拥塞窗口大小置为 1。</div></li><li><div>补充： TCP 在刚开始通信时，并没有设置相应的慢启动阈值，而是在超时重传时，才会设置当时拥塞窗口一半的大小。</div></li></ol></ol><li><div>延迟应答： 不是接收到数据，就立刻返回 ACK，如果接收端处理速度比较快，等到缓冲区处理掉一些数据，可以返回一个更大一些的窗口。</div></li><ol><li><div>窗口越大，网络吞吐量越大，传输效率越高；</div></li><li><div>所有包都会延迟应答吗？ 答： 数量限制，每隔 N（通常为 2） 个包应答一次； 时间限制：超过最大延迟时间（通常 200ms）应答一次。</div></li></ol><li><div>捎带应答： 将 ACK 和 FIN 一起返回</div></li><li><div>粘包问题 （站在<span style="font-weight: bold;">应用层</span>的角度）</div></li><ol><li><div>在传输层角度，TCP 是一个一个报文过来的，按照序号放在缓冲区；</div></li><li><div>如何避免粘包问题</div></li><ol><li><div>对于定长的包，保证每次按照固定大小读取。</div></li><li><div>对于变长的包，可在包头位置，约定总长度的一个字段； 或者在包和包之间使用明确的分隔符。</div></li></ol><li><div>UDP 是否存在粘包问题</div></li><ol><li><div>UDP 如果上交数据，存在“报文长度”字段；</div></li><li><div>UDP 是一个一个交付数据，有明确的数据边界；</div></li><li><div>应用层角度看来，UDP 要么收到完整的报文，要么不收。</div></li></ol></ol><li><div>TCP 异常</div></li><ol><li><div>进程终止：释放文件描述符，仍然可以发送 FIN，和正常关闭没有区别；</div></li><li><div>机器重启： 和进程终止一样</div></li><li><div>机器掉电/断网：接收端认为连接还在，一旦接收端有写入操作，发现连接不在，会进行 reset。 TCP 内置有保活定时器，定期询问对方是否还在，如果不在，会断开连接。</div></li></ol><li><div>TCP 小结：</div></li><ol><li><div>保证可靠： 校验和、序列号、确认应答、超时重传、拥塞控制、流量控制、连接管理</div></li><ol><li><div>提高性能： 滑动窗口、快速重传（既保证可靠，也可以提高性能）、延迟应答、捎带应答</div></li></ol><li><div>基于 TCP 的协议： HTTP、HTTPS、SSH、Telnet、FTP、SMTP等。</div></li><li><div>适用场景： 文件传输、重要的状态更新等；QQ文件传输、浏览器用的 HTTP等</div></li></ol><li><div>提高网络l利用率规范：</div></li><ol><li><div>Nagle 算法：如果两个条件都不满足，暂时等待一段时间进行数据发送</div></li><ol><li><div>已发送的数据已经收到确认应答时</div></li><li><div>可以发送最大段长度（MSS）的数据时</div></li></ol><li><div>延迟确认应答</div></li><li><div>捎带应答</div></li></ol></ol><li><div>UDP：无连接、不可靠、面向数据报 </div></li><ol><li><div>如果发送端使用 UDP 调用 sendto 传输 100 个字节的数据,那么接收端也必须调用对应的一次 recvfrom 接收 100 个字节，而 <span style="font-weight: bold;">不能 </span>循环调用 10 次，每次接收 10 个字节</div></li><li><div>UDP 没有真正意义的发送缓冲区，调用 sendto 会直接交给内核，由内核将数据传给网络层协议进行后续的传输动作；</div></li><li><div>UDP 有接收缓冲区，但不能保证 UDP 报文的顺序 和 发送 UDP 报的顺序一致；如果缓冲区满，则后续的数据会被丢弃。</div></li><li><div>UDP 首部有一个 16 位最大长度，也意味着 UDP 能传输的最大长度是 64 K（包含 UDP 首部）。如果传输数据超过 64 K，需要在应用层手动的分包多次发送。</div></li><li><div>基于 UDP 的应用层协议： NFS（网络文件系统）、TFTP（简单文件传输协议）、DHCP（动态主机配置协议）、BOOTP（启动协议：用于无盘设备启动）、DNS（域名解析协议等）。</div></li><li><div>适用场景：视频传输、实时通信等。QQ语音、QQ视频</div></li></ol></ol><li><div>应用层</div></li><ol><li><div><br/></div></li></ol><li><div>网络层</div></li><ol><li><div>IP 协议头</div></li><li><div>网段划分</div></li><ol><li><div>网络号 和 主机号： 网络号保证网段间的不同标识； 主机号表示同一网段中的主机的不同标识。</div></li><li><div>DHCP：自动给子网内新增的主机节点分配 IP 地址， 一般路由器带有该功能。</div></li><li><div>特殊 IP 地址： </div></li><ol><li><div>IP 地址中主机地址全 0，是网络号，代表这个局域网；</div></li><li><div>IP 地址中主机地址全 1，是广播地址，用于给同一链路中相互连接的所有主机发送数据包；</div></li><li><div>127.* 的 IP 地址用于本地回环测试。</div></li></ol><li><div>IP 地址数量限制</div></li><ol><li><div>动态分配 IP 地址</div></li><li><div>NAT（网络地址转换） 技术: 子网内的主机需要 和 外网进行通信时，路由器将 IP 首部中的 IP 地址，进行替换，这样逐级替换，最终数据包中的 IP 地址成为一个公网 IP。</div></li><li><div>IPv6</div></li></ol></ol><li><div>私有 IP 和 公网 IP</div></li><li><div>路由</div></li></ol><li><div>数据链路层</div></li><ol><li><div>MAC地址： 48 位，不能修改，全球唯一；</div></li><li><div>MTU（最大传输单元）： 通信某一层所能通过的最大数据包大小。 通常与通信接口有关。</div></li><ol><li><div>对 IP 协议的影响： 对较大的 IP 包进行分包处理</div></li><li><div>对 UDP 协议的影响： 一旦 UDP 携带数据超过 1472（1500 - 20（IP首部） - 8（UDP 首部）），就会在网络层分成多个 IP 报。如果 UDP 在网络层被分片，数据被丢失概率会增加。</div></li><li><div>对 TCP 协议的影响：TCP 的单个数据报的最大消息长度，称为 MSS。 MSS 受制于 MTU。</div></li></ol><li><div>ARP 协议（介于数据链路层 和 网络层之间的协议）</div></li><ol><li><div>作用：建立了主机 IP 地址 和 MAC 地址的映射关系。</div></li><li><div>工作流程、ARP 报格式</div></li></ol><li><div>ICMP 协议（网络层协议）</div></li><ol><li><div>主要功能： </div></li><ol><li><div>确认 IP 包是否成功到达目标地址；</div></li><li><div>通知在发送过程中  IP 包被丢弃的原因；</div></li><li><div>基于 IP 协议工作；</div></li><li><div>只能搭配 IPv4 使用； ICMPv6</div></li></ol></ol><li><div>NAT 技术： 当前解决 IP 地址不够用的主要手段，是路由器的一个重要功能。</div></li><ol><li><div>NAT 技术的缺陷：</div></li><ol><li><div>由于 NAT 依赖转换表，所以有诸多限制</div></li><li><div>无法从 NAT 外部向内部服务器建立连接；</div></li><li><div>转换表的生成和销毁需要额外开销；</div></li><li><div>通信过程一旦 NAT 设备异常，即使存在热备，所有的 TCP 连接也都会断开。</div></li></ol><li><div>NAT 和 代理服务器区别</div></li><ol><li><div>应用角度， NAT 设备是网络基础设备之一，解决 IP 不足问题，代理服务器更贴近具体应用</div></li><li><div>底层实现角度： NAT 工作在网络层直接对 IP 进行替换，代理服务器工作在应用层</div></li><li><div>实现范围： NAT 一般在局域网的出口部署，代理服务器可在局域网，可在广域网，也可跨网</div></li><li><div>部署位置： NAT 一般集成在防火墙，路由器等硬件设备，代理服务器则是一个软件程序，需要部署在服务器上。</div></li></ol></ol></ol></ol><div><br/></div><div>2.socket 编程：</div><ol><li><div>socket 常见 API : 创建（socket）、绑定（bind）、监听（listen）、接收（accept）、建立连接（connect）</div></li><li><div>sockaddr 结构： struct sockaddr,  struct sockaddr_in（地址类型、端口号、IP 地址）,  struct sockaddr_un</div></li><li><div>地址转换函数：注意， 在 APUE 中，明确提出 inet_ntoa 是线程不安全的，使用 inet_ntop 函数。inet_ntop(AF_INET, &amp;client_socket.sin_addr, buf_ip, sizeof(buf_ip)); </div></li></ol><div><br/></div><div>3.高级 I/O</div></div><ol><li><div>五种 I/O 模型</div></li></ol><ol start="2"><ol><li><div>阻塞 I/O：在内核将数据准备在好之前，系统调用一直等待，所有的套接字，默认是阻塞方式；</div></li><li><div>非阻塞 I/O：如果内核还没有将数据准备好之前，系统调用仍然会直接返回，并且返回 EWOULDBLOCK 错误码；</div></li><li><div>信号驱动 I/O：内核将数据准备好的时候，使用 SIGIO 信号通知应用程序进行 IO 操作；</div></li><li><div>IO 多路转接：与阻塞 IO 的不同之处，在于 IO 多路转接可以同时等待多个文件描述符的就绪状态；</div></li><li><div>异步 IO：由内核在数据拷贝完成时，通知应用程序， 与信号驱动不同的是， 信号驱动是什么时候可以开始拷贝数据。</div></li></ol><li><div> 同步通信 和 异步通信</div></li><ol><li><div>同步通信： 在发起一个调用时，没有得到结果之前，调用不会返回。 由调用者主动等待这个调用的结果</div></li><li><div>异步通信：调用发起之后，调用直接返回，所以调用者无法直接获得调用的结果。在调用发出后，被调用者通过状态、信号来通知调用者，或者通过回调函数处理这个调用。</div></li><li><div>附记 ： 进程/线程 同步 ： 为完成某个任务创建两个或多个线程，线程需要在某些位置协调他们 工作次序，进而等待、传递信息所产生的制约关系。 尤其是访问临界资源时。</div></li></ol><li><div>阻塞 和 非阻塞： </div></li><ol><li><div>阻塞：指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果后才返回。</div></li><li><div>非阻塞：不能立刻获得结果之前，该调用不会阻塞当前线程。</div></li></ol><li><div>I/O 多路转接之 select</div></li><ol><li><div>select 系统调用是用来监视多个文件描述符的状态变化的；</div></li><li><div>程序会停在 select 这里等待，直到被监视的文件描述符有一个或多个发生了变化。</div></li><li><div>特点：</div></li><ol><li><div>可监控文件描述符的个数取决于 sizeof(fd_set)； </div></li><li><div>将 fd 加入 select 监控集的同时，还要再使用一个数据结构 array  保存放到 select 监控集中的fd</div></li><ol><li><div>用于在 select 返回时，作为元数据和 fd_set 进行 FD_ISSET 判断；</div></li><li><div>select 返回后，把以前加入的但并无事件发生的 fd 清除，每次开始 select 前都要重新从 array 中取得 fd 逐一加入（FD_ZERO 最先），扫描 array 同时获得 fd 最大值 maxfd，用于 select 的第一个参数。</div></li></ol></ol><li><div>缺点：</div></li><ol><li><div>每次调用 select，都要手动设置 fd 集合，从接口使用角度非常不便；</div></li><li><div>每次调用，都要把 fd 集合从内核态拷贝到用户态，如果 fd 很多时开销很大；</div></li><li><div>每次调用，都要遍历传进来的所有的 fd , 在 fd 很多时开销很大；</div></li><li><div>可以支持的 select 的文件描述符数量太少</div></li></ol></ol><li><div>I/O 多路转接之 poll</div></li><ol><li><div>poll 的优点：</div></li><ol><li><div>不同 select 使用三个位图来表示 三个 fdset 的方式, poll 使用了一个 poll_fd 指针；</div></li><li><div>poll_fd 结构包含了要监视的 event 和发生的 event ，不再使用 select &quot;参数-值&quot; 的传递方式，接口使用更方便；</div></li><li><div>poll 文件描述符数量没有最大的限制。</div></li></ol><li><div>poll 的缺点：</div></li><ol><li><div>poll 返回后也需要轮询 poll_fd 获取就绪的描述符；</div></li><li><div>每次调用 poll 都需要把大量 的 poll_fd 结构由用户态拷贝到内核；</div></li><li><div>同时连接大量的客户端同一时刻可能只有很少就绪状态，随着描述符的数量的增长效率直线下降。</div></li></ol></ol><li><div>I/O 多路转接之 epoll</div></li><ol><li><div>epoll 相关系统调用： epoll_create, epoll_ctl, epoll_wait</div></li><li><div><br/></div></li></ol></ol><div><br/></div><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 