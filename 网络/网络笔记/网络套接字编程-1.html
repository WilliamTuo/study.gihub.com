<html>
<head>
  <title>网络套接字编程-1</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600240 (zh-CN, DDL); Windows/6.1.1 (Win32);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1514"/>
<h1>网络套接字编程-1</h1>

<div>
<span><div><div><div><div>主要是传输层 tcp/udp </div><div><br/></div><div>    tcp ：面向连接、可靠传输、字节流服务</div><div>            优点：可靠传输，传输灵活</div><div>            缺点：传输速度低，数据粘包</div><div>适用场景：</div><div>        数据安全性要求比较高： 比如，文件传输， 保证可靠</div><div><br/></div><div><br/></div><div>    udp：无连接、不可靠、面向数据报</div><div>            优点：传输速度快，无粘包</div><div>            缺点：不可靠</div><div>使用场景：</div><div>        数据安全性不是很高，实时性高： 比如，视频传输， 保证传输速度</div><div><br/></div><hr/><div>socket 套接字编程：</div><div>    网络编程涉及对网卡的操作，因此操作系统提供了一套接口供用户操作-------socket 接口</div><div>    </div><div>    客户端程序/服务端程序</div><div>    在网络编程中，客户端就是主动的一方</div><div>    </div><div>    客户端必须知道服务端的地址信息（ip + port）</div><div>    服务端必须在指定的地址准备就绪</div><div><br/></div><hr/><div>udp 编程步骤：</div><div>    服务端：</div><div>            创建套接字</div><div>                建立网卡和进程的关系        </div><div>            为套接字绑定地址信息</div><div>                确定操作的数据是哪一部分数据</div><div>            接收/发送数据</div><div>            关闭套接字</div><div>                </div><div>    客户端：</div></div><div>            创建套接字</div><div>            绑定（不主动绑定，由操作系统处理）</div><div>            接收/发送数据</div><div>            关闭套接字</div><hr/><div>tcp 编程步骤：</div><div>    服务端 ：</div><div>        创建套接字</div><div>        绑定地址</div><div>        开始监听</div><div><br/></div><div>    客户端：</div><div>        创建套接字</div><div>        向服务器发起请求                                      // SYN 泛洪攻击</div><div><br/></div><div>    服务端：</div><div>        创建一个新的套接字</div><div>        获取新创建的套接字</div><div>        收发数据</div><div>    </div><div>    客户端：</div><div>        收发数据</div><div><br/></div><div>    客户端：</div><div>        关闭套接字</div><div>    服务端：</div><div>        关闭套接字</div><div><br/></div><hr/><div><br/></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       #include &lt;sys/types.h&gt;          /* See NOTES */</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       #include &lt;sys/socket.h&gt;</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       int listen(int sockfd, int backlog);</span></div></div><div>参数介绍：</div><div>        sockfd：套接字描述符</div><div>        backlog：定义已完成连接队列的最大连接数</div><div>                        每一个客户端都会创建新的socket ，一个新的连接建立连接有一个过程，如果这个新的连接已经完成三次握手过程，就将这个新的 socket 放在这个队列中。</div><div>     backlog 决定了 同意时间的最大并发连接数。</div><div>        返回值： 成功， 0， 失败， -1    </div><div><br/></div><div>listen 第二个参数： 一个整型数据</div><div>    用于定义一个挂起的连接队列最大节点数，表示同一个时间的一个并发连接数（同一时间能够接收多少个新客户端的连接）。</div><div><br/></div><hr/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">#include &lt;sys/types.h&gt;          /* See NOTES */</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       #include &lt;sys/socket.h&gt;</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       int connect(int sockfd, </span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                    const struct sockaddr *addr,  //服务端地址信息</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                   socklen_t addrlen); //地址信息长度</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                    返回值：    成功， 0， 失败， -1</span></div></div><div>            </div><hr/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       #include &lt;sys/types.h&gt;          /* See NOTES */</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       #include &lt;sys/socket.h&gt;</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       int accept(int sockfd,         //套接字描述符</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                        struct sockaddr *addr,    //新连接的客户端地址信息</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                         socklen_t *addrlen);    //用于确定要获取地址信息的长度，接收实际长度</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">                                    返回值：新建的 socket 连接的套接字描述符， 失败， -1</span></div></div><div>accept 的简介：</div><div>    每一个客户端向服务端发起连接请求，在服务器都会新建一个 socket 结构， 当这个新的连接走完三次握手，完成建立连接，这个新的 socket 结构放到已完成连接队列中。</div><div>    accept 获取新连接的客户端，实际上是从已完成连接队列获取一个已完成连接的 socket ，并且返回这个新连接的 socket 套接字的描述符。</div><div><br/></div><hr/><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>       </span>#include &lt;sys/types.h&gt;</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       #include &lt;sys/socket.h&gt;</span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       ssize_t send(int sockfd,   // 套接字描述符</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span> const void *buf, // 要发送的数据</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span> size_t len, <span>    </span><span>    //数据长度</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span>int flags);<span>    </span><span>    // 0，默认阻塞</span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span><br/></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span><span>    </span><span>    </span><span>    </span><span>    返回值： 实际发送的数据长度， 失败 ， -1</span><br/></span></span></div><div><br style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"/></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">       ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span>    </span><span>    </span><span>    </span><span>    返回值： &gt;0 实际获取数据长度；</span><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    =0 连接断开；</span><br/></span></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    -1  出错</span><br/></span></span></div><div>附记：</div><div><span>    </span><span>errno :  EAGAIN 表示缓冲区无数据</span><br/></div><div><span><span>    </span><span>    </span><span>    EINTR 当前 的接收数据操作被信号打断</span><br/></span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);"><span><br/></span></span></div></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 